<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulasi CT-Scan 3D dengan Sinogram</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0c1a2d, #1a3658);
            color: white;
            overflow: hidden;
            height: 100vh;
        }
        
        #header {
            padding: 15px;
            text-align: center;
            background: rgba(0, 0, 0, 0.4);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 10;
            position: relative;
        }
        
        h1 {
            font-size: 2.2rem;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            color: #4fc3f7;
        }
        
        .subtitle {
            font-size: 1rem;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.4;
        }
        
        #main-container {
            display: flex;
            height: calc(100vh - 120px);
        }
        
        #left-panel {
            width: 300px;
            background: rgba(15, 25, 45, 0.9);
            padding: 15px;
            overflow-y: auto;
            box-shadow: 5px 0 15px rgba(0, 0, 0, 0.3);
            border-right: 1px solid rgba(100, 150, 255, 0.2);
        }
        
        #center-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        #canvas-container {
            width: 90%;
            height: 90%;
            position: relative;
        }
        
        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            outline: none;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        
        #right-panel {
            width: 400px;
            background: rgba(15, 25, 45, 0.9);
            padding: 15px;
            overflow-y: auto;
            box-shadow: -5px 0 15px rgba(0, 0, 0, 0.3);
            border-left: 1px solid rgba(100, 150, 255, 0.2);
        }
        
        .panel {
            background: rgba(30, 45, 70, 0.7);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(79, 195, 247, 0.3);
        }
        
        h2 {
            font-size: 1.3rem;
            margin-bottom: 12px;
            color: #4fc3f7;
            border-bottom: 1px solid rgba(79, 195, 247, 0.3);
            padding-bottom: 6px;
        }
        
        .control-group {
            margin-bottom: 12px;
        }
        
        label {
            display: block;
            margin-bottom: 6px;
            font-weight: 500;
            font-size: 0.9rem;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
        }
        
        input[type="range"] {
            flex: 1;
            height: 6px;
            background: rgba(79, 195, 247, 0.3);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4fc3f7;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }
        
        .value-display {
            width: 50px;
            text-align: center;
            margin-left: 8px;
            background: rgba(0, 0, 0, 0.3);
            padding: 4px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.85rem;
        }
        
        button {
            background: linear-gradient(to right, #0288d1, #4fc3f7);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            width: 100%;
            margin-top: 5px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            font-size: 0.9rem;
        }
        
        button:hover {
            background: linear-gradient(to right, #039be5, #29b6f6);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .info-text {
            font-size: 0.85rem;
            line-height: 1.4;
            margin-top: 8px;
            opacity: 0.9;
        }
        
        .scan-visualization {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            border-radius: 5px;
            margin-top: 8px;
            font-family: monospace;
            font-size: 0.85rem;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 12px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            font-size: 0.75rem;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 4px;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.3rem;
            color: white;
            text-align: center;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
        }
        
        .highlight {
            color: #4fc3f7;
            font-weight: bold;
        }
        
        .mode-buttons {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        
        .mode-buttons button {
            flex: 1;
        }
        
        .active-mode {
            background: linear-gradient(to right, #f44336, #ef5350) !important;
        }
        
        .scan-progress {
            height: 8px;
            background: rgba(79, 195, 247, 0.2);
            border-radius: 4px;
            margin-top: 8px;
            overflow: hidden;
        }
        
        .scan-progress-bar {
            height: 100%;
            background: linear-gradient(to right, #4fc3f7, #29b6f6);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .slice-display {
            text-align: center;
            margin-top: 10px;
            font-size: 0.9rem;
        }
        
        #sinogram-container {
            margin-top: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            padding: 10px;
        }
        
        #sinogram-title {
            text-align: center;
            margin-bottom: 8px;
            font-size: 1.1rem;
            color: #4fc3f7;
            font-weight: bold;
        }
        
        #sinogram-canvas {
            width: 100%;
            height: 300px;
            background: black;
            border: 2px solid #4fc3f7;
            border-radius: 5px;
        }
        
        .sinogram-info {
            font-size: 0.9rem;
            margin-top: 8px;
            text-align: center;
            opacity: 0.9;
        }
        
        .sinogram-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            font-size: 0.8rem;
        }
        
        .sinogram-value {
            background: rgba(0, 0, 0, 0.3);
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .instructions {
            background: rgba(79, 195, 247, 0.1);
            border: 1px solid rgba(79, 195, 247, 0.3);
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
            font-size: 0.8rem;
        }
        
        .instructions h3 {
            color: #4fc3f7;
            margin-bottom: 5px;
            font-size: 0.9rem;
        }
        
        .instructions ul {
            margin-left: 15px;
        }
        
        .instructions li {
            margin-bottom: 3px;
        }
        
        .key-indicator {
            background: rgba(79, 195, 247, 0.2);
            border: 1px solid #4fc3f7;
            border-radius: 4px;
            padding: 8px;
            margin-top: 10px;
            text-align: center;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }
        
        .key-active {
            background: rgba(79, 195, 247, 0.5);
            box-shadow: 0 0 10px #4fc3f7;
        }
        
        .key-indicator .key {
            display: inline-block;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #4fc3f7;
            border-radius: 3px;
            padding: 2px 6px;
            margin: 0 2px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>Simulasi CT-Scan 3D dengan Sinogram</h1>
        <p class="subtitle">Visualisasi proses pemindaian CT dengan objek sederhana dan tampilan sinogram waktu nyata</p>
    </div>
    
    <div id="main-container">
        <div id="left-panel">
            <div class="panel">
                <h2>Kontrol Pemindaian</h2>
                
                <div class="control-group">
                    <label>Mode Pemindaian</label>
                    <div class="mode-buttons">
                        <button id="mode-scan" class="active-mode">Jalankan CT Scan</button>
                        <button id="mode-reconstruct">Rekonstruksi 3D</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="scan-speed">Kecepatan Pemindaian</label>
                    <div class="slider-container">
                        <input type="range" id="scan-speed" min="1" max="10" step="1" value="5">
                        <div class="value-display" id="scan-speed-value">5</div>
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="slice-position">Posisi Irisan</label>
                    <div class="slider-container">
                        <input type="range" id="slice-position" min="0" max="100" step="1" value="50">
                        <div class="value-display" id="slice-position-value">50%</div>
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="object-density">Kepadatan Objek</label>
                    <div class="slider-container">
                        <input type="range" id="object-density" min="1" max="5" step="1" value="3">
                        <div class="value-display" id="object-density-value">3</div>
                    </div>
                </div>
                
                <div class="control-group">
                    <label for="chamber-transparency">Transparansi Ruang</label>
                    <div class="slider-container">
                        <input type="range" id="chamber-transparency" min="0" max="100" step="1" value="20">
                        <div class="value-display" id="chamber-transparency-value">20%</div>
                    </div>
                </div>
                
                <button id="start-scan-btn">Mulai Pemindaian</button>
                <button id="reset-btn">Reset Simulasi</button>
                
                <div class="scan-progress">
                    <div class="scan-progress-bar" id="scan-progress-bar"></div>
                </div>
                
                <div class="slice-display" id="slice-display">
                    Sudut: 0°/360°
                </div>
                
                <div class="key-indicator" id="object-control-indicator">
                    <div>Kontrol Objek: Tahan tombol <span class="key">O</span> + Klik & Tarik untuk memindahkan objek</div>
                    <div>Scroll mouse untuk mengubah ukuran</div>
                </div>
            </div>
            
            <div class="panel">
                <h2>Informasi CT-Scan</h2>
                <div class="info-text">
                    <p>Computed Tomography (CT) menggunakan <span class="highlight">proyeksi sinar-X</span> dari berbagai sudut untuk merekonstruksi <span class="highlight">gambar penampang</span>.</p>
                    <p>Sinogram menunjukkan data proyeksi mentah yang dikumpulkan selama pemindaian CT, dengan setiap baris mewakili satu sudut proyeksi.</p>
                    <p id="physics-explanation">Simulasi ini menunjukkan bagaimana sinar-X melewati objek dengan kepadatan berbeda untuk membuat gambar proyeksi.</p>
                </div>
                
                <div class="scan-visualization">
                    <div>Sudut Saat Ini: <span id="current-angle">0°</span></div>
                    <div>Intensitas Sinar-X: <span id="xray-intensity">100%</span></div>
                    <div>Sinyal Terdeteksi: <span id="detected-signal">85%</span></div>
                </div>
                
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #4fc3f7;"></div>
                        <span>Sumber Sinar-X</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ff6b6b;"></div>
                        <span>Silinder</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #51cf66;"></div>
                        <span>Detektor</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background-color: #ffd93d;"></div>
                        <span>Balok</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="center-container">
            <div id="canvas-container">
                <canvas id="renderCanvas"></canvas>
                <div id="loading">
                    <div>Memuat Simulasi CT-Scan...</div>
                    <div style="font-size: 0.9rem; margin-top: 10px;">Menginisialisasi lingkungan 3D dan komponen pemindaian</div>
                </div>
            </div>
        </div>
        
        <div id="right-panel">
            <div class="panel">
                <h2>Tampilan Sinogram</h2>
                <div id="sinogram-container">
                    <div id="sinogram-title">DATA PROYEKSI (SINOGRAM)</div>
                    <canvas id="sinogram-canvas"></canvas>
                    <div class="sinogram-stats">
                        <div class="sinogram-value">Sudut: <span id="sinogram-angle">0°</span></div>
                        <div class="sinogram-value">Proyeksi: <span id="projection-count">0</span>/180</div>
                    </div>
                </div>
                <div class="info-text" style="margin-top: 12px;">
                    <p>Sinogram memvisualisasikan data proyeksi mentah. Setiap garis horizontal mewakili satu proyeksi pada sudut tertentu.</p>
                    <p>Area terang menunjukkan penyerapan sinar-X yang lebih sedikit, area gelap menunjukkan penyerapan lebih banyak.</p>
                    <p><span class="highlight">Analisis Pola:</span> Kurva karakteristik dalam sinogram sesuai dengan bentuk dan posisi objek yang dipindai.</p>
                </div>
            </div>
            
            <div class="panel">
                <h2>Nilai Edukasi</h2>
                <div class="info-text">
                    <p>Visualisasi ini membantu siswa memahami:</p>
                    <ul style="margin-left: 18px; margin-top: 8px;">
                        <li>Bagaimana pemindai CT memperoleh data dari berbagai sudut</li>
                        <li>Konsep atenuasi dan kepadatan jaringan</li>
                        <li>Rekonstruksi gambar dari data proyeksi</li>
                        <li>Visualisasi 3D struktur internal</li>
                        <li>Hubungan antara geometri objek dan pola sinogram</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Get the canvas and loading element
            const canvas = document.getElementById('renderCanvas');
            const sinogramCanvas = document.getElementById('sinogram-canvas');
            const loading = document.getElementById('loading');
            const objectControlIndicator = document.getElementById('object-control-indicator');
            
            // Set up sinogram canvas context
            const sinogramCtx = sinogramCanvas.getContext('2d');
            const sinogramWidth = sinogramCanvas.width = 360;
            const sinogramHeight = sinogramCanvas.height = 180;
            
            // Initialize sinogram with black background
            sinogramCtx.fillStyle = 'black';
            sinogramCtx.fillRect(0, 0, sinogramWidth, sinogramHeight);
            
            // Create the Babylon.js engine
            const engine = new BABYLON.Engine(canvas, true, {
                preserveDrawingBuffer: true,
                stencil: true
            });
            
            // Create the scene
            const createScene = function() {
                const scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color3(0.05, 0.1, 0.15);
                
                // Create camera
                const camera = new BABYLON.ArcRotateCamera(
                    "camera", 
                    -Math.PI / 2, 
                    Math.PI / 2.5, 
                    12, 
                    new BABYLON.Vector3(0, 2, 0), 
                    scene
                );
                
                // Camera controls
                camera.attachControl(canvas, true);
                camera.lowerRadiusLimit = 8;
                camera.upperRadiusLimit = 25;
                camera.wheelPrecision = 50;
                
                // Create light
                const light = new BABYLON.HemisphericLight(
                    "light", 
                    new BABYLON.Vector3(0, 1, 0), 
                    scene
                );
                light.intensity = 0.7;
                
                // Create directional light for better illumination
                const dirLight = new BABYLON.DirectionalLight(
                    "dirLight", 
                    new BABYLON.Vector3(-1, -2, -1), 
                    scene
                );
                dirLight.position = new BABYLON.Vector3(10, 10, 10);
                dirLight.intensity = 0.5;
                
                // Create materials
                const cylinderMat = new BABYLON.StandardMaterial("cylinderMat", scene);
                cylinderMat.diffuseColor = new BABYLON.Color3(0.9, 0.4, 0.4);
                cylinderMat.alpha = 0.9; // More opaque for better contrast
                
                const blockMat = new BABYLON.StandardMaterial("blockMat", scene);
                blockMat.diffuseColor = new BABYLON.Color3(0.95, 0.85, 0.3);
                blockMat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.3);
                blockMat.alpha = 0.9; // More opaque for better contrast
                
                const xraySourceMat = new BABYLON.StandardMaterial("xraySourceMat", scene);
                xraySourceMat.diffuseColor = new BABYLON.Color3(0.3, 0.8, 1.0);
                xraySourceMat.emissiveColor = new BABYLON.Color3(0.1, 0.4, 0.8);
                
                const detectorMat = new BABYLON.StandardMaterial("detectorMat", scene);
                detectorMat.diffuseColor = new BABYLON.Color3(0.3, 0.8, 0.4);
                detectorMat.emissiveColor = new BABYLON.Color3(0.1, 0.3, 0.1);
                
                const xrayBeamMat = new BABYLON.StandardMaterial("xrayBeamMat", scene);
                xrayBeamMat.diffuseColor = new BABYLON.Color3(0.8, 0.9, 1.0);
                xrayBeamMat.emissiveColor = new BABYLON.Color3(0.5, 0.7, 1.0);
                xrayBeamMat.alpha = 0.6;
                
                const chamberMat = new BABYLON.StandardMaterial("chamberMat", scene);
                chamberMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.4);
                chamberMat.alpha = 0.2; // Semi-transparent
                
                // Create CT scanner gantry (semi-transparent chamber)
                const gantry = BABYLON.MeshBuilder.CreateCylinder(
                    "gantry", 
                    {diameter: 10, height: 6, tessellation: 64}, 
                    scene
                );
                gantry.material = chamberMat;
                gantry.position.y = 3;
                
                // Create opening in gantry
                const gantryHole = BABYLON.MeshBuilder.CreateCylinder(
                    "gantryHole", 
                    {diameter: 6, height: 6.2, tessellation: 64}, 
                    scene
                );
                gantryHole.material = new BABYLON.StandardMaterial("holeMat", scene);
                gantryHole.material.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.2);
                gantryHole.material.alpha = 0.1;
                gantryHole.position.y = 3;
                
                // Create smaller objects: cylinder and block
                const cylinder = BABYLON.MeshBuilder.CreateCylinder(
                    "cylinder", 
                    {diameter: 1.2, height: 2, tessellation: 32}, // Smaller size
                    scene
                );
                cylinder.material = cylinderMat;
                cylinder.position.y = 2.5;
                cylinder.position.x = 0.8; // Moved closer to center
                
                const block = BABYLON.MeshBuilder.CreateBox(
                    "block", 
                    {width: 1, height: 1.5, depth: 1}, // Smaller size
                    scene
                );
                block.material = blockMat;
                block.position.y = 2;
                block.position.x = -0.8; // Moved closer to center
                block.position.z = 0.8;
                
                // Create X-ray source - placed further from center
                const xraySource = BABYLON.MeshBuilder.CreateSphere(
                    "xraySource", 
                    {diameter: 0.5, segments: 16}, 
                    scene
                );
                xraySource.material = xraySourceMat;
                xraySource.position.x = 5; // Increased from 4.5 to 5
                xraySource.position.y = 3;
                
                // Create detector - placed further from center with smaller width
                const detector = BABYLON.MeshBuilder.CreateBox(
                    "detector", 
                    {width: 5, height: 4, depth: 0.2}, // Smaller width
                    scene
                );
                detector.material = detectorMat;
                detector.position.x = -5; // Increased from -4.5 to -5
                detector.position.y = 3;
                
                // Create X-ray beam - adjusted length for new positions
                const xrayBeam = BABYLON.MeshBuilder.CreateCylinder(
                    "xrayBeam", 
                    {diameter: 0.1, height: 10}, // Adjusted length
                    scene
                );
                xrayBeam.material = xrayBeamMat;
                xrayBeam.position.y = 3;
                
                // Group scanner components (X-ray source, detector, beam)
                const scannerAssembly = new BABYLON.TransformNode("scannerAssembly", scene);
                xraySource.parent = scannerAssembly;
                detector.parent = scannerAssembly;
                xrayBeam.parent = scannerAssembly;
                
                // Create cross-section plane
                const slicePlane = BABYLON.MeshBuilder.CreatePlane(
                    "slicePlane", 
                    {width: 6, height: 6}, 
                    scene
                );
                const sliceMat = new BABYLON.StandardMaterial("sliceMat", scene);
                sliceMat.diffuseColor = new BABYLON.Color3(0.2, 0.6, 0.9);
                sliceMat.alpha = 0.3;
                slicePlane.material = sliceMat;
                slicePlane.position.y = 2.5;
                slicePlane.isVisible = false;
                
                // Create reconstruction volume
                const reconstructionVolume = BABYLON.MeshBuilder.CreateBox(
                    "reconstructionVolume", 
                    {width: 6, height: 5, depth: 6}, 
                    scene
                );
                const volumeMat = new BABYLON.StandardMaterial("volumeMat", scene);
                volumeMat.diffuseColor = new BABYLON.Color3(0.1, 0.3, 0.6);
                volumeMat.alpha = 0.2;
                reconstructionVolume.material = volumeMat;
                reconstructionVolume.position.y = 2.5;
                reconstructionVolume.isVisible = false;
                
                // Variables for object manipulation
                let selectedObject = null;
                let isDragging = false;
                let isObjectControlActive = false;
                let originalPointerX, originalPointerY;
                let originalObjectX, originalObjectZ;
                
                // Keyboard event listeners for object control
                const onKeyDown = function(evt) {
                    if (evt.key === 'o' || evt.key === 'O') {
                        isObjectControlActive = true;
                        objectControlIndicator.classList.add('key-active');
                    }
                };
                
                const onKeyUp = function(evt) {
                    if (evt.key === 'o' || evt.key === 'O') {
                        isObjectControlActive = false;
                        objectControlIndicator.classList.remove('key-active');
                        
                        // Reset material if object was selected
                        if (selectedObject === cylinder) {
                            cylinderMat.emissiveColor = new BABYLON.Color3(0, 0, 0);
                        } else if (selectedObject === block) {
                            blockMat.emissiveColor = new BABYLON.Color3(0, 0, 0);
                        }
                        
                        selectedObject = null;
                        isDragging = false;
                    }
                };
                
                // Add keyboard event listeners
                scene.onKeyboardObservable.add((kbInfo) => {
                    switch (kbInfo.type) {
                        case BABYLON.KeyboardEventTypes.KEYDOWN:
                            onKeyDown(kbInfo.event);
                            break;
                        case BABYLON.KeyboardEventTypes.KEYUP:
                            onKeyUp(kbInfo.event);
                            break;
                    }
                });
                
                // Set up pointer events for object manipulation
                scene.onPointerObservable.add((pointerInfo) => {
                    switch (pointerInfo.type) {
                        case BABYLON.PointerEventTypes.POINTERDOWN:
                            if (isObjectControlActive && pointerInfo.pickInfo.hit && 
                                (pointerInfo.pickInfo.pickedMesh === cylinder || 
                                 pointerInfo.pickInfo.pickedMesh === block)) {
                                selectedObject = pointerInfo.pickInfo.pickedMesh;
                                isDragging = true;
                                
                                // Store original positions
                                originalPointerX = scene.pointerX;
                                originalPointerY = scene.pointerY;
                                originalObjectX = selectedObject.position.x;
                                originalObjectZ = selectedObject.position.z;
                                
                                // Change material to indicate selection
                                if (selectedObject === cylinder) {
                                    cylinderMat.emissiveColor = new BABYLON.Color3(0.3, 0, 0);
                                } else {
                                    blockMat.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0);
                                }
                            }
                            break;
                            
                        case BABYLON.PointerEventTypes.POINTERUP:
                            if (isDragging) {
                                isDragging = false;
                                
                                // Only reset material if object control is no longer active
                                if (!isObjectControlActive) {
                                    if (selectedObject === cylinder) {
                                        cylinderMat.emissiveColor = new BABYLON.Color3(0, 0, 0);
                                    } else {
                                        blockMat.emissiveColor = new BABYLON.Color3(0, 0, 0);
                                    }
                                }
                                
                                selectedObject = null;
                            }
                            break;
                            
                        case BABYLON.PointerEventTypes.POINTERMOVE:
                            if (isObjectControlActive && isDragging && selectedObject) {
                                // Calculate movement delta
                                const deltaX = (scene.pointerX - originalPointerX) * 0.1;
                                const deltaZ = (scene.pointerY - originalPointerY) * 0.1;
                                
                                // Update object position
                                selectedObject.position.x = originalObjectX + deltaX;
                                selectedObject.position.z = originalObjectZ - deltaZ;
                                
                                // Constrain object to within scanner bounds
                                const maxDistance = 2.5;
                                const distanceFromCenter = Math.sqrt(
                                    selectedObject.position.x * selectedObject.position.x + 
                                    selectedObject.position.z * selectedObject.position.z
                                );
                                
                                if (distanceFromCenter > maxDistance) {
                                    const scale = maxDistance / distanceFromCenter;
                                    selectedObject.position.x *= scale;
                                    selectedObject.position.z *= scale;
                                }
                            }
                            break;
                            
                        case BABYLON.PointerEventTypes.POINTERWHEEL:
                            if (isObjectControlActive && pointerInfo.pickInfo.hit && 
                                (pointerInfo.pickInfo.pickedMesh === cylinder || 
                                 pointerInfo.pickInfo.pickedMesh === block)) {
                                const delta = pointerInfo.event.wheelDelta;
                                const scaleFactor = delta > 0 ? 1.1 : 0.9;
                                
                                // Scale the object
                                pointerInfo.pickInfo.pickedMesh.scaling.x *= scaleFactor;
                                pointerInfo.pickInfo.pickedMesh.scaling.y *= scaleFactor;
                                pointerInfo.pickInfo.pickedMesh.scaling.z *= scaleFactor;
                                
                                // Constrain scaling to reasonable limits
                                const minScale = 0.3;
                                const maxScale = 3.0;
                                
                                pointerInfo.pickInfo.pickedMesh.scaling.x = Math.max(minScale, 
                                    Math.min(maxScale, pointerInfo.pickInfo.pickedMesh.scaling.x));
                                pointerInfo.pickInfo.pickedMesh.scaling.y = Math.max(minScale, 
                                    Math.min(maxScale, pointerInfo.pickInfo.pickedMesh.scaling.y));
                                pointerInfo.pickInfo.pickedMesh.scaling.z = Math.max(minScale, 
                                    Math.min(maxScale, pointerInfo.pickInfo.pickedMesh.scaling.z));
                            }
                            break;
                    }
                });
                
                // UI Elements
                const scanSpeedSlider = document.getElementById('scan-speed');
                const slicePositionSlider = document.getElementById('slice-position');
                const objectDensitySlider = document.getElementById('object-density');
                const chamberTransparencySlider = document.getElementById('chamber-transparency');
                const startScanBtn = document.getElementById('start-scan-btn');
                const resetBtn = document.getElementById('reset-btn');
                const modeScanBtn = document.getElementById('mode-scan');
                const modeReconstructBtn = document.getElementById('mode-reconstruct');
                
                const scanSpeedValue = document.getElementById('scan-speed-value');
                const slicePositionValue = document.getElementById('slice-position-value');
                const objectDensityValue = document.getElementById('object-density-value');
                const chamberTransparencyValue = document.getElementById('chamber-transparency-value');
                const currentAngleDisplay = document.getElementById('current-angle');
                const xrayIntensityDisplay = document.getElementById('xray-intensity');
                const detectedSignalDisplay = document.getElementById('detected-signal');
                const scanProgressBar = document.getElementById('scan-progress-bar');
                const sliceDisplay = document.getElementById('slice-display');
                const physicsExplanation = document.getElementById('physics-explanation');
                const sinogramAngleDisplay = document.getElementById('sinogram-angle');
                const projectionCountDisplay = document.getElementById('projection-count');
                
                // Update chamber transparency
                chamberTransparencySlider.addEventListener('input', function() {
                    const value = parseInt(this.value);
                    chamberTransparencyValue.textContent = value + '%';
                    
                    // Update chamber material transparency (invert value for alpha)
                    chamberMat.alpha = 1 - (value / 100);
                });
                
                // Simulation state
                let isScanning = false;
                let currentAngle = 0;
                let scanProgress = 0;
                let totalScanTime = 0;
                let currentMode = 'scan';
                let reconstructionData = [];
                let sinogramData = new Array(180);
                let projectionCount = 0;
                
                // Initialize sinogram data
                for (let i = 0; i < 180; i++) {
                    sinogramData[i] = new Array(sinogramWidth).fill(0);
                }
                
                // Update UI values
                scanSpeedSlider.addEventListener('input', function() {
                    scanSpeedValue.textContent = this.value;
                });
                
                slicePositionSlider.addEventListener('input', function() {
                    const value = parseInt(this.value);
                    slicePositionValue.textContent = value + '%';
                    
                    // Update slice plane position
                    const sliceY = 0.5 + (value / 100) * 4;
                    slicePlane.position.y = sliceY;
                    
                    // Update reconstruction visibility based on slice
                    if (currentMode === 'reconstruct') {
                        updateReconstructionSlice(value);
                    }
                });
                
                objectDensitySlider.addEventListener('input', function() {
                    objectDensityValue.textContent = this.value;
                    
                    // Update object materials based on density
                    const density = parseInt(this.value);
                    // Keep objects opaque regardless of density for better contrast
                    cylinderMat.alpha = 0.9;
                    blockMat.alpha = 0.9;
                });
                
                // Mode switching
                modeScanBtn.addEventListener('click', function() {
                    currentMode = 'scan';
                    modeScanBtn.classList.add('active-mode');
                    modeReconstructBtn.classList.remove('active-mode');
                    physicsExplanation.textContent = "Simulasi ini menunjukkan bagaimana sinar-X melewati objek dengan kepadatan berbeda untuk membuat gambar proyeksi.";
                    
                    // Show/hide appropriate elements
                    slicePlane.isVisible = false;
                    reconstructionVolume.isVisible = false;
                    scannerAssembly.setEnabled(true);
                    
                    resetSimulation();
                });
                
                modeReconstructBtn.addEventListener('click', function() {
                    currentMode = 'reconstruct';
                    modeReconstructBtn.classList.add('active-mode');
                    modeScanBtn.classList.remove('active-mode');
                    physicsExplanation.textContent = "Tampilan ini menunjukkan proses rekonstruksi 3D dari data proyeksi yang diperoleh.";
                    
                    // Show/hide appropriate elements
                    slicePlane.isVisible = true;
                    reconstructionVolume.isVisible = true;
                    scannerAssembly.setEnabled(false);
                    
                    resetSimulation();
                });
                
                // Start scan
                startScanBtn.addEventListener('click', function() {
                    if (!isScanning) {
                        isScanning = true;
                        scanProgress = 0;
                        totalScanTime = 0;
                        startScanBtn.textContent = "Hentikan Pemindaian";
                        reconstructionData = [];
                        projectionCount = 0;
                        clearSinogram();
                    } else {
                        isScanning = false;
                        startScanBtn.textContent = "Mulai Pemindaian";
                    }
                });
                
                // Reset simulation function
                function resetSimulation() {
                    isScanning = false;
                    currentAngle = 0;
                    scanProgress = 0;
                    totalScanTime = 0;
                    startScanBtn.textContent = "Mulai Pemindaian";
                    scannerAssembly.rotation.y = 0;
                    scanProgressBar.style.width = "0%";
                    sliceDisplay.textContent = "Sudut: 0°/360°";
                    currentAngleDisplay.textContent = "0°";
                    reconstructionData = [];
                    projectionCount = 0;
                    clearSinogram();
                    
                    // Reset object positions and scales
                    cylinder.position.x = 0.8;
                    cylinder.position.z = 0;
                    cylinder.scaling = new BABYLON.Vector3(1, 1, 1);
                    
                    block.position.x = -0.8;
                    block.position.z = 0.8;
                    block.scaling = new BABYLON.Vector3(1, 1, 1);
                    
                    // Reset chamber transparency
                    chamberTransparencySlider.value = 20;
                    chamberTransparencyValue.textContent = "20%";
                    chamberMat.alpha = 0.8; // 1 - 0.2
                    
                    // Reset sinogram data
                    for (let i = 0; i < 180; i++) {
                        sinogramData[i] = new Array(sinogramWidth).fill(0);
                    }
                }
                
                // Reset simulation
                resetBtn.addEventListener('click', resetSimulation);
                
                // Clear sinogram
                function clearSinogram() {
                    sinogramCtx.fillStyle = 'black';
                    sinogramCtx.fillRect(0, 0, sinogramWidth, sinogramHeight);
                    projectionCountDisplay.textContent = "0";
                    sinogramAngleDisplay.textContent = "0°";
                }
                
                // Update reconstruction slice
                function updateReconstructionSlice(slicePercent) {
                    // In a real implementation, this would update the 3D reconstruction
                    // visualization based on the slice position and acquired data
                    
                    // For this simulation, we'll just adjust the transparency
                    const alpha = 0.1 + (slicePercent / 100) * 0.3;
                    volumeMat.alpha = alpha;
                }
                
                // Calculate if a point is inside cylinder
                function isPointInCylinder(x, z, cx, cz, radius) {
                    return (x - cx) * (x - cx) + (z - cz) * (z - cz) <= radius * radius;
                }
                
                // Calculate if a point is inside block
                function isPointInBlock(x, z, bx, bz, width, depth) {
                    return x >= bx - width/2 && x <= bx + width/2 && 
                           z >= bz - depth/2 && z <= bz + depth/2;
                }
                
                // Simulate X-ray attenuation through objects for a specific detector position
                function calculateAttenuationForDetectorPosition(angle, detectorPos) {
                    const angleRad = (angle * Math.PI) / 180;
                    const density = parseInt(objectDensitySlider.value);
                    
                    // Calculate ray from source to detector pixel
                    const sourceX = 5 * Math.cos(angleRad);
                    const sourceZ = 5 * Math.sin(angleRad);
                    
                    // Detector position along the detector array (-1 to 1)
                    const detectorOffset = (detectorPos - 0.5) * 2; // Convert to -1 to 1 range
                    const detectorX = -5 * Math.cos(angleRad) - Math.sin(angleRad) * detectorOffset * 2.5;
                    const detectorZ = -5 * Math.sin(angleRad) + Math.cos(angleRad) * detectorOffset * 2.5;
                    
                    // Sample points along the ray
                    const samples = 50;
                    let totalAttenuation = 0;
                    
                    for (let i = 0; i < samples; i++) {
                        const t = i / (samples - 1);
                        const x = sourceX * (1 - t) + detectorX * t;
                        const z = sourceZ * (1 - t) + detectorZ * t;
                        
                        // Check if point is inside objects (using current positions and scales)
                        const cylinderRadius = 0.6 * cylinder.scaling.x;
                        if (isPointInCylinder(x, z, cylinder.position.x, cylinder.position.z, cylinderRadius)) {
                            totalAttenuation += 0.9 * (density / 5); // Higher attenuation for more contrast
                        }
                        
                        const blockHalfWidth = 0.5 * block.scaling.x;
                        const blockHalfDepth = 0.5 * block.scaling.z;
                        if (isPointInBlock(x, z, block.position.x, block.position.z, blockHalfWidth * 2, blockHalfDepth * 2)) {
                            totalAttenuation += 0.8 * (density / 5); // Higher attenuation for more contrast
                        }
                    }
                    
                    return Math.min(1, totalAttenuation / samples);
                }
                
                // Update sinogram display
                function updateSinogram(angle) {
                    const row = Math.floor(angle / 2); // 180 rows for 360 degrees
                    
                    if (row >= 0 && row < 180) {
                        for (let col = 0; col < sinogramWidth; col++) {
                            const detectorPos = col / sinogramWidth;
                            const attenuation = calculateAttenuationForDetectorPosition(angle, detectorPos);
                            sinogramData[row][col] = attenuation;
                            
                            const intensity = Math.floor(255 * (1 - attenuation));
                            sinogramCtx.fillStyle = `rgb(${intensity}, ${intensity}, ${intensity})`;
                            sinogramCtx.fillRect(col, row, 1, 1);
                        }
                        
                        projectionCount++;
                        projectionCountDisplay.textContent = projectionCount;
                        sinogramAngleDisplay.textContent = Math.round(angle) + "°";
                    }
                }
                
                // Calculate average attenuation for display
                function calculateAverageAttenuation(angle) {
                    let total = 0;
                    const samples = 10;
                    
                    for (let i = 0; i < samples; i++) {
                        const detectorPos = i / samples;
                        total += calculateAttenuationForDetectorPosition(angle, detectorPos);
                    }
                    
                    return total / samples;
                }
                
                // Main simulation loop
                scene.registerBeforeRender(function() {
                    const dt = engine.getDeltaTime() / 1000; // Convert to seconds
                    totalScanTime += dt;
                    
                    if (isScanning && currentMode === 'scan') {
                        // Get scan speed from UI
                        const scanSpeed = parseInt(scanSpeedSlider.value);
                        
                        // Update scanner rotation
                        currentAngle += dt * scanSpeed * 10;
                        if (currentAngle >= 360) {
                            currentAngle = 0;
                            scanProgress = 100;
                            isScanning = false;
                            startScanBtn.textContent = "Mulai Pemindaian";
                        } else {
                            scanProgress = (currentAngle / 360) * 100;
                        }
                        
                        scannerAssembly.rotation.y = (currentAngle * Math.PI) / 180;
                        
                        // Update X-ray beam position and orientation
                        xrayBeam.position.x = Math.cos((currentAngle * Math.PI) / 180) * 5;
                        xrayBeam.position.z = Math.sin((currentAngle * Math.PI) / 180) * 5;
                        xrayBeam.rotation.y = (currentAngle * Math.PI) / 180 + Math.PI / 2;
                        
                        // Calculate and display attenuation
                        const attenuation = calculateAverageAttenuation(currentAngle);
                        const detectedSignal = (0.3 + (1 - attenuation) * 0.7) * 100;
                        
                        currentAngleDisplay.textContent = Math.round(currentAngle) + "°";
                        xrayIntensityDisplay.textContent = "100%";
                        detectedSignalDisplay.textContent = Math.round(detectedSignal) + "%";
                        
                        // Update progress bar and slice display
                        scanProgressBar.style.width = scanProgress + "%";
                        sliceDisplay.textContent = "Sudut: " + Math.round(currentAngle) + "°/360°";
                        
                        // Update sinogram every 2 degrees
                        if (Math.round(currentAngle) % 2 === 0 && Math.round(currentAngle) !== 0) {
                            updateSinogram(Math.round(currentAngle));
                        }
                        
                        // Store reconstruction data (simplified)
                        if (Math.round(currentAngle) % 10 === 0) {
                            reconstructionData.push({
                                angle: currentAngle,
                                attenuation: attenuation
                            });
                        }
                    }
                });
                
                // Hide loading message after a short delay
                setTimeout(function() {
                    loading.style.display = 'none';
                }, 2000);
                
                return scene;
            };
            
            const scene = createScene();
            
            // Run the engine
            engine.runRenderLoop(function() {
                scene.render();
            });
            
            // Handle window resize
            window.addEventListener('resize', function() {
                engine.resize();
            });
        });
    </script>
</body>
</html>